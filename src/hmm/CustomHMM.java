package hmm;


import org.javatuples.Triplet;

public class CustomHMM {

	// Lambda L = (A, B, pi)
	// Either generated by Problem 3 or given for Problem 1/2.
	double[][] A = null;
	double[][] B = null;
	double[] pi = null;

	// Other notable variables distinct to HMMs.
	int[][] Os;
	int[] O;
	int N;
	int M;
	int T;

	// Notable variables for problem 3.
	int maxIters = 0;
	int iters = 0;
	double oldLogProb = 0;
	double epsilon = 0;
	
	// Tables used during normalized alpha and beta pass.
	double[][] alpha;
	double[][] beta;
	double[][] gamma;
	double[][][] digamma;
	double[] c;
	
	/**
	 * Constructor for the discrete HMM for Problem 1 and 2, where L = (A, B, pi) is provided.
	 * @param observationSeq 	The observation sequence O, containing (O[0],O[1],...,O[T-1]).
	 * @param A            		The transition matrix. Tracks probability that one state n (row) will go to another state n (column).
	 * @param B            		The observation matrix. Tracks probabilistic relationship between a state n (row) and an observation symbol m (column).
	 * @param pi           		The initial state distribution matrix. Tracks the probability of starting at a given state n. 
	 */
	public CustomHMM(int[] observationSeq, double[][] A, double[][] B, double[] pi) {
		this.O = observationSeq;
		this.A = A;
		this.B = B;
		this.pi = pi;
		
		// We can get N and M from B, as B is a matrix of size (N x M).
		this.N = B.length;
		this.M = B[0].length;
		
		// T is the length of the observation sequence.
		this.T = observationSeq.length;
		
		// Initializing alpha, beta, gamma, and scaling factor tables.
		alpha = new double[T][N];
		beta = new double[T][N];
		gamma = new double[T][N];
		c = new double[T];
	}

	/**
	 * Constructor for the discrete HMM for Problem 3. Only numStates N is a hyper-parameter.
	 * @param observations    The array containing n-fold observation sequences O, which themselves are of form (O[0],O[1],...,O[T-1]).
	 * @param numStates       The number of states, N.
	 * @param numObservations The number of observation symbols per state, M.
	 */
	public CustomHMM(int[][] observations, int numStates, int numObservations, int maxIters) {
		this.Os = observations;
		this.N = numStates;
		this.M = numObservations;
		
		// T is the length of the observation sequence.
		this.T = observations[0].length;

		// Adjustable parameters.
		final double PERCENT_RANGE = .01; // Max percent difference from the uniform origin value for any number in the matrix.
		final double SUM = 1;
		this.maxIters = maxIters;

		// Generating stochastic non-uniform values for each matrix in L = (A, B, pi)
		this.A = generateStochasticMatrix(PERCENT_RANGE, N, N, SUM); // A = NxN matrix
		this.B = generateStochasticMatrix(PERCENT_RANGE, N, M, SUM); // B = NxM matrix
		this.pi = generateStochasticRow(PERCENT_RANGE, N, SUM); // pi = 1xN matrix
		
		// Initializing alpha, beta, gamma, and scaling factor tables.
		alpha = new double[T][N];
		beta = new double[T][N];
		gamma = new double[T][N];
		digamma = new double[T][N][N];
		c = new double[T];
		
		// Other initializations.
		this.iters = 0; // Keeps track of current iteration.
		oldLogProb = Double.NEGATIVE_INFINITY; // Our initial score is as low as possible to ensure monotonous step increases.
		epsilon = 0.0001;
	}
	
	/**
	 * Calculates the probability that observation sequence O occurs given model L = (A, B, pi).
	 * @return Returns P(O|L).
	 */
	public double solveProblem1() {
		alpha_pass();
		return calculateLogProb();
	}
	
	/*
	 * Calculates the optimal state sequence given an initial observation sequence O and model L = (A, B, pi)
	 * @return Returns the optimal state sequence as an array.
	 */
	public int[] solveProblem2() {
		// Do the alpha pass and store P(O|L).
		double probOGivenL = solveProblem1();
		beta_pass();
		// Obtain gamma value yt(i) for all t, i.
		for (int t = 0; t <= T-1; t++) {
			for (int i = 0; i <= N-1; i++) {
				gamma[t][i] = (alpha[t][i] * beta[t][i]) / probOGivenL;
			}
		}
		
		// Compute Xt, the most likely state sequence in time range [0:T-1].
		int[] Xt = new int[T];
		
		// Obtain the most likely state at time t and place it into state sequence Xt.
		for (int t = 0; t <= T-1; t++) {
			double max = 0;
			int mostLikelyState = -1;
			for (int i = 0; i <= N-1; i++) {
				if (gamma[t][i] > max) {
					max = gamma[t][i];
					mostLikelyState = i;
				}
			}
			Xt[t] = mostLikelyState;
		}
		return Xt;
	}
	
	/**
	 * Generates a model L = (A, B, pi) that maximizes the probability for a given observation sequence.
	 * @return Returns L as a Triplet containing 2D double array A, 2D double array B, and double array pi.
	 */
	public Triplet<double[][], double[][], double[]> solveProblem3() {
		
		// Re-estimate model until a reasonably accurate one is created.
		boolean done = false;
		while (!done) {
			
			// Use a new observation sequence with each re-estimation to prevent over-fitting.
			// Os contains n-fold observation sequences, where n = iters.
			this.O = Os[iters];
			
			// Run all passes + re-estimation to estimate a model.
			alpha_pass();
			beta_pass();
			gamma_pass();
			reestimateModel();
			
			// Compute log[P(O|L)]
			double logProb = calculateLogProb();
			
			// Check whether to continue iterating or to stop.
			iters += 1;
			if ((iters < maxIters) && (logProb > oldLogProb)) {
				oldLogProb = logProb;
			}
			else {
				done = true;
			}
			
			// Write current model results to file.
			ArrayPrinter ap = new ArrayPrinter("model_outputs.txt");
			ap.writeToFile("Iteration #" + iters + ": log[P(O|L)] = " + logProb);
			ap.writeToFile("A:");
			ap.writeToFile(A);
			ap.writeToFile("B:");
			ap.writeToFile(B);
			ap.writeToFile("pi:");
			ap.writeToFile(pi);
			ap.writeToFile("");
			ap.close();
		}
		Triplet<double[][], double[][], double[]> model = new Triplet<>(A, B, pi);
		return model;
	}
	
	
	/**
	 * Calculates log[P(O|L)], assuming alpha pass has already occurred.
	 * @return Returns log[P(O|L)] as a double.
	 */
	private double calculateLogProb() {
		double logProbOGivenL = 0;
		for (int j = 0; j <= T-1; j++) {
			logProbOGivenL += Math.log(c[j]);
		}
		logProbOGivenL *= -1;		// Return a negative value.
		logProbOGivenL /= T;		// Divide by length of observation sequence to make it independent of it.
		return logProbOGivenL;
	}

	/**
	 * Does a forward pass on the HMM.
	 */
	private void alpha_pass() {
		
		// Compute a0(i).
		c[0] = 0;
		for (int i = 0; i <= N-1; i++) {
			alpha[0][i] = pi[i] * B[i][O[0]]; 
			c[0] += alpha[0][i];
		}
		
		// Scale a0(i).
		c[0] = 1 / c[0];
		for (int i = 0; i <= N-1; i++) {
			alpha[0][i] *= c[0];
		}
		
		// Compute at(i), except for t=0 which was already computed.
		for (int t = 1; t <= T-1; t++) {
			c[t] = 0;
			for (int i = 0; i <= N-1; i++) {
				alpha[t][i] = 0;
				for (int j = 0; j <= N-1; j++) {
					alpha[t][i] += alpha[t-1][j] * A[j][i];
				}
				alpha[t][i] *= B[i][O[t]]; 
				c[t] += alpha[t][i];
			}
			
			// Scale at(i)
			if (c[t] == 0) {
				c[t] = epsilon;
			}
			c[t] = 1 / c[t];
			for (int i = 0; i <= N-1; i++) {
				alpha[t][i] *= c[t];
			}
		}
	}

	/**
	 * Does a backwards pass on the HMM.
	 */
	public void beta_pass() {
		
		// Let b(T-1)(i) = 1, scaled by C(T-1).
		for (int i = 0; i <= N-1; i++) {
			beta[T-1][i] = 1 * c[T-1];
		} 
		
		// Beta pass.
		for (int t = T-2; t >= 0; t--) {
			for (int i = 0; i <= N-1; i++) {
				beta[t][i] = 0;
				for (int j = 0; j <= N-1; j++) {
					beta[t][i] += A[i][j] * B[j][O[t+1]] * beta[t+1][j];
				} 
				
				// Scale bt(i) /w same scale factor as at(i).
				beta[t][i] *= c[t];
			} 
		}
	}
	
	/**
	 * The scaled gamma and digamma passes, used for Problem 3. Only works if alpha, beta passes have already occured.
	 */
	private void gamma_pass() {
		for (int t = 0; t <= T-2; t++) {
			// Denominator used to scale and normalize gamma, di-gamma later
			double denom = 0;
			for (int i = 0; i <= N-1; i++) {
				for (int j = 0; j <= N-1; j++) {
					denom += alpha[t][i] * A[i][j] * B[j][O[t+1]] * beta[t+1][j];
				}
			}
			// Solve for gamma, digamma
			for (int i = 0; i <= N-1; i++) {
				gamma[t][i] = 0;
				for (int j = 0; j <= N-1; j++) {
					digamma[t][i][j] = (alpha[t][i] * A[i][j] * B[j][O[t+1]] * beta[t+1][j]) / denom;
					gamma[t][i] += digamma[t][i][j];
				}
			}
		}
		
		// Special case for gamma[t-1]
		double denom = 0;
		for (int i = 0; i <= N-1; i++) {
			denom += alpha[T-1][i];
		}
		for (int i = 0; i <= N-1; i++) {
			gamma[T-1][i] = alpha[T-1][i] / denom;
		}
	}
	
	/**
	 * Re-estimates L = (A, B, pi).
	 */
	private void reestimateModel() {
		// Re-estimation of the initial state matrix, pi.
		for (int i = 0; i <= N-1; i++) {
			pi[i] = gamma[0][i];
		}
		
		// Re-estimation of the transition matrix, A.
		for (int i = 0; i <= N-1; i++) {
			for (int j = 0; j <= N-1; j++) {
				double numer = 0;
				double denom = 0;
				for (int t = 0; t <= T-2; t++) {
					numer += digamma[t][i][j];
					denom += gamma[t][i];
				}
				// Replace denominator by smallest nonzero positive number to prevent div-by-zero.
				if (denom == 0) {
					denom = epsilon;
				}
				A[i][j] = numer/denom;
			}
		}
		
		// Re-estimation of the observation matrix, B.
		for (int i = 0; i <= N-1; i++) {
			for (int j = 0; j <= M-1; j++) {
				double numer = 0;
				double denom = 0;
				// Changed from T-2.
				for (int t = 0; t <= T-1; t++) {
					if (O[t] == j) {
						numer += gamma[t][i];
					}
					denom += gamma[t][i];
				}
				// Replace denominator by smallest nonzero positive number to prevent div-by-zero.
				if (denom == 0) {
					denom = epsilon;
				}
				B[i][j] = numer/denom;
			}
		}
	}

	/**
	 * Generates a stochastic row with non-uniform values.
	 * @param range       The upper limit on deviation from a uniform value for each of the row's values..
	 * @param numElements The size of the row.
	 * @param sum         The desired total for the row's values when added up.
	 * @return Returns a stochastic row with non-uniform values.
	 */
	private double[] generateStochasticRow(double range, int numElements, double sum) {
		double uniformVal = sum / numElements;
		double[] stochasticRow = new double[numElements];
		double sumSoFar = 0;
		// Generate a random value between [uniformVal - range : uniformVal + range] for
		// all but the last element.
		for (int i = 0; i < numElements - 1; i++) {
			double deviation = uniformVal * range * Math.random();
			// Decide whether the value will positively or negatively deviate from the
			// uniform value.
			if (Math.random() < 0.5) {
				deviation *= -1;
			}
			stochasticRow[i] = uniformVal + deviation;
			sumSoFar += stochasticRow[i];
		}
		// Generate the value for the last element, ensuring everything adds up to sum.
		// Note that it might not be w/in range.
		stochasticRow[numElements - 1] = sum - sumSoFar;
		return stochasticRow;
	}

	/**
	 * Generates a stochastic matrix with stochastic rows containing non-uniform values. Note that columns ARE NOT stochastic.
	 * @param range      The upper limit on deviation from a uniform value for each of the row's values.
	 * @param numRows    The number of rows.
	 * @param numColumns The number of columns.
	 * @param sum        The desired total for the row's values when added up.
	 * @return Returns a stochastic matrix with non-uniform values.
	 */
	private double[][] generateStochasticMatrix(double range, int numRows, int numColumns, double sum) {
		double[][] stochasticMatrix = new double[numRows][numColumns];
		// Generate stochastic rows for the matrix.
		for (int i = 0; i < numRows; i++) {
			stochasticMatrix[i] = generateStochasticRow(range, numColumns, sum);
		}
		return stochasticMatrix;
	}

	public double[][] getA() {
		return A;
	}

	public double[][] getB() {
		return B;
	}

	public double[] getPi() {
		return pi;
	}
}
