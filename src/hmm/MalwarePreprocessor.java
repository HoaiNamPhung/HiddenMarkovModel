package hmm;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;

public class MalwarePreprocessor {
	
	// Singleton instance for pre-processing.
	private static MalwarePreprocessor pp = null;
	
	// Private constructor to prevent re-instantiation
	private MalwarePreprocessor() {
		
	}
	
	// Get the existing instance.
	public static MalwarePreprocessor getPreprocessor() {
		if (pp == null) {
			pp = new MalwarePreprocessor();
		}
		return pp;
	}
	
	/**
	 * Converts a directory of files to an array of observation sequences, given their desired length and opcode mappings.
	 * @param dirPath	The path to the directory of files.
	 * @param symbolMap	The dictionary that maps opcodes -> symbols.
	 * @param T			The desired length of each observation sequence O.
	 * @return Returns an array of observation sequences.	
	 * @throws IOException There was an error in reading the file line-by-line.
	 * @throws FileNotFoundException The specified file could not be found or accessed.
	 */
	public int[][] getObservationSequences(String dirPath, Map<String, Integer> symbolMap, int T) throws FileNotFoundException, IOException {
		File[] allFiles = new File(dirPath).listFiles();
		int[][] arrO = new int[allFiles.length][T];
		
		// Go through each file and convert their opcode sequences into an array containing their corresponding symbol sequences.
		for (int i = 0; i < allFiles.length; i++) {
			BufferedReader br = new BufferedReader(new FileReader(allFiles[i]));
			String opcode;
			int t = 0;										// The current observation symbol in the sequence.
			while ( ((opcode = br.readLine()) != null) && (t < T) ) {
				Integer symbol = symbolMap.get(opcode);				
				// Special case for getting observation sequence for files that weren't used for mapping.
				// Opcodes unrecognized by existing dictionary are translated to white noise symbol, 0.
				if (symbol == null) {
					symbol = 0;
				}
				// Add symbol to our array of observation sequences.
				arrO[i][t] = symbol;
				t++;
			}
			br.close();
		}
		return arrO;
	}
		
	/**
	 * Prepares data-sets from all given files.
	 * @param dirPath The path to the directory of files.
	 * @param numFiles The number of files to use from our data-set.
	 * @param numSymbols The number of unique symbols desired (M) for an HMM.
	 * @return Returns a list of k-sized maps of symbols representing states, usable for training a HMM.
	 * @throws IOException There was an error in reading the file line-by-line.
	 * @throws FileNotFoundException The specified file could not be found or accessed.
	 */
	public Map<String, Integer> getSymbolMappings(String dirPath, int numSymbols) throws FileNotFoundException, IOException {
		File[] allFiles = new File(dirPath).listFiles();
		return mapSymbols(allFiles, numSymbols);
	}
	
	/**
	 * Prepares data-sets from a limited number of given files.
	 * @param dirPath The path to the directory of files to randomly select from.
	 * @param numFiles The number of files to use from our data-set.
	 * @param numSymbols The number of unique symbols desired (M) for an HMM.
	 * @return Returns a list of k-sized maps of symbols representing states, usable for training a HMM.
	 * @throws IOException There was an error in reading the file line-by-line.
	 * @throws FileNotFoundException The specified file could not be found or accessed.
	 */
	public Map<String, Integer> getSymbolMappings(String dirPath, int numFiles, int numSymbols) throws FileNotFoundException, IOException {
		File[] allFiles = generateRandomFiles(dirPath, numFiles);
		return mapSymbols(allFiles, numSymbols);
	}
	
	/**
	 * Returns a dictionary that maps opcodes -> symbols.
	 * @param files The array of files to check across for symbols.
	 * @param numSymbols The number of unique symbols desired (M), including a symbol containing all excess white noise.
	 * @return Returns a n-sized map of symbols that each show number of occurrences across files.
	 * @throws IOException There was an error in reading the file line-by-line.
	 * @throws FileNotFoundException The specified file could not be found or accessed.
	 */
	public Map<String, Integer> mapSymbols(File[] files, int numSymbols) throws IOException, FileNotFoundException {
		
		// Our dictionary for opcodes -> symbols.
		Map<String, Integer> mapDict = new HashMap<>();
		
		// Read the files and record the number of opcodes across all of them.
		Map<String, Integer> opcodeFreqMap = new HashMap<>();
		for (int i = 0; i < files.length; i++) {
			BufferedReader br = new BufferedReader(new FileReader(files[i]));
			String opcode;
			while ((opcode = br.readLine()) != null) {
				opcodeFreqMap.merge(opcode, 1, (a, b) -> a + b);	// If key doesn't exist, initialize value to 1. Otherwise, increment value.
			}
			br.close();
		}
		
		// Sort the HashMap by frequency by converting it to an ArrayList.
		List<Map.Entry<String, Integer>> entries = new ArrayList<>();
		for (Map.Entry<String, Integer> e : opcodeFreqMap.entrySet()) {
			entries.add(e);
		}
		Collections.sort(entries, new Comparator<Map.Entry<String, Integer>>() {
			public int compare(Map.Entry<String, Integer> e1,
						           Map.Entry<String, Integer> e2) {
				return (e1.getValue()).compareTo(e2.getValue());
			}
		});
		
		// Assure that there are enough opcodes; if not, reduce the number of symbols produced.
		int numOpcodes = entries.size();
		if (entries.size() < numSymbols) {
			numSymbols = entries.size();
		}
			
		// Truncate the table to only contain n most frequent opcodes, and give them a numeric symbol, starting from 1.
		for (int i = 0; i < numSymbols - 1; i++) {
			int opcodeIndex = numOpcodes - 1 - i;
			Entry<String, Integer> entry = entries.get(opcodeIndex);
			
			// Record entry in dictionary of opcodes -> symbols.
			mapDict.put(entry.getKey(), i + 1);
		}
			
		// Relegate excess symbols to single white noise symbol, denoted 0.
		for (int i = numSymbols - 1; i < entries.size(); i++) {
			int opcodeIndex = numOpcodes - 1 - i;
			Entry<String, Integer> entry = entries.get(opcodeIndex);
			mapDict.put(entry.getKey(), 0);
		}	
		return mapDict;
	}
	
	/**
	 * Generates an array of n-randomly selected files from a directory.
	 * No uniqueness checking, so repetition may occur. Unlikely with large data-set of files.
	 * @param dirPath The path to the directory of files to randomly select from.
	 * @param numFiles The number of files to randomly obtain.
	 * @return Returns an array containing k-files, randomly selected.
	 */
	public File[] generateRandomFiles(String dirPath, int numFiles) {
		Random rand = new Random();
		File[] randomFiles = new File[numFiles];
		File[] allFiles = new File(dirPath).listFiles();
		for (int i = 0; i < numFiles; i++) {
			File randomFile = allFiles[rand.nextInt(allFiles.length)];
			randomFiles[i] = randomFile;
		}
		return randomFiles;
	}
}
